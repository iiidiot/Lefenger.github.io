<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Today is my whole life.">
<meta property="og:type" content="website">
<meta property="og:title" content="AbstractSky">
<meta property="og:url" content="http://lefenger.com/page/3/index.html">
<meta property="og:site_name" content="AbstractSky">
<meta property="og:description" content="Today is my whole life.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AbstractSky">
<meta name="twitter:description" content="Today is my whole life.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://lefenger.com/page/3/"/>





  <title>AbstractSky</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?20f853bf595da1e2982aa23897a0c23c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AbstractSky</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://lefenger.com/2017/07/26/Opengl（三）——渲染出一个三角形/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lefeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AbstractSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/Opengl（三）——渲染出一个三角形/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T17:09:54+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">#define GLEW_STATIC</div><div class="line">#include &lt;GL/glew.h&gt;</div><div class="line">#include &lt;glfw3.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">//顶点着色器GLSL代码的字符串</div><div class="line">const GLchar* vertexshader = &quot;#version 330 core\n&quot;                     </div><div class="line">    &quot;layout (location = 0) in vec3 position;\n&quot;</div><div class="line">    &quot;void main()\n&quot;</div><div class="line">    &quot;&#123;\n&quot;</div><div class="line">    &quot;gl_Position = vec4(position.x, position.y, position.z, 1.0);\n&quot;</div><div class="line">	&quot;&#125;\0&quot;;</div><div class="line">//片段着色器的GLSL代码的字符串</div><div class="line">const GLchar* fragmentshader = &quot;#version 330 core\n&quot;</div><div class="line">&quot;out vec4 color;\n&quot;</div><div class="line">&quot;void main()\n&quot;</div><div class="line">&quot;&#123;\n&quot;</div><div class="line">&quot;color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</div><div class="line">&quot;&#125;\n\0&quot;;</div><div class="line">//顶点坐标</div><div class="line">GLfloat vertices[] = &#123;</div><div class="line">	-0.5f, -0.5f, 0.0f,</div><div class="line">	0.5f, -0.5f, 0.0f,</div><div class="line">	0.0f, 0.5f, 0.0f</div><div class="line">&#125;;</div><div class="line">void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)</div><div class="line">&#123;</div><div class="line">	if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)</div><div class="line">		glfwSetWindowShouldClose(window, GL_TRUE);</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	glfwInit();</div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</div><div class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</div><div class="line">	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);</div><div class="line"></div><div class="line">	GLFWwindow* window = glfwCreateWindow(800, 600, &quot;NB&quot;, nullptr, nullptr);</div><div class="line">	if (window == nullptr)</div><div class="line">	&#123;</div><div class="line">		std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;</div><div class="line">		glfwTerminate();</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	glfwMakeContextCurrent(window);</div><div class="line">	glewExperimental = GL_TRUE;</div><div class="line">	GLenum err = glewInit();</div><div class="line"></div><div class="line">	if (GLEW_OK!=err)</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;Failed to initialize GLEW&quot; &lt;&lt; endl;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	glViewport(0, 0, 800, 600);</div><div class="line"></div><div class="line">	glfwSetKeyCallback(window, key_callback);</div><div class="line">	//初始化顶点缓存对象</div><div class="line">	GLuint VBO;</div><div class="line">	glGenBuffers(1, &amp;VBO);</div><div class="line">	//上面的顶点坐标数据传入到缓存中</div><div class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</div><div class="line">	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</div><div class="line">	//初始化顶点着色器对象</div><div class="line">	GLuint vertexShader;</div><div class="line">	vertexShader = glCreateShader(GL_VERTEX_SHADER);</div><div class="line">	glShaderSource(vertexShader, 1, &amp;vertexshader, NULL);</div><div class="line">	//初始化片段着色器对象</div><div class="line">	GLuint fragmentShader;</div><div class="line">	fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</div><div class="line">	glShaderSource(fragmentShader, 1, &amp;fragmentshader, NULL);</div><div class="line">	//创建着色器程序对象，链接并编译所有着色器</div><div class="line">	GLuint shaderProgram;</div><div class="line">	shaderProgram = glCreateProgram();</div><div class="line">	glAttachShader(shaderProgram, vertexShader);</div><div class="line">	glAttachShader(shaderProgram, fragmentShader);</div><div class="line">	glLinkProgram(shaderProgram);</div><div class="line">	</div><div class="line">	//检测着色器的编译是否成功并输出调试信息</div><div class="line">	GLint success;</div><div class="line">	GLchar infoLog[512];</div><div class="line">	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</div><div class="line">	if (!success)</div><div class="line">	&#123;</div><div class="line">		glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);</div><div class="line">		std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</div><div class="line">	&#125;</div><div class="line">	GLint successf;</div><div class="line">	GLchar infoLogf[512];</div><div class="line">	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;successf);</div><div class="line">	if (!successf)</div><div class="line">	&#123;</div><div class="line">		glGetShaderInfoLog(fragmentShader, 512, NULL, infoLogf);</div><div class="line">		std::cout &lt;&lt; &quot;ERROR::SHADER::Fragment::COMPILATION_FAILED\n&quot; &lt;&lt; infoLogf &lt;&lt; std::endl;</div><div class="line">	&#125;</div><div class="line">	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</div><div class="line">	if (!success)</div><div class="line">	&#123;</div><div class="line">		glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);</div><div class="line">	&#125;</div><div class="line">	glUseProgram(shaderProgram);</div><div class="line">	glDeleteShader(vertexShader);</div><div class="line">	glDeleteShader(fragmentShader);</div><div class="line"></div><div class="line">	//初始化顶点数组对象，它可以存储单位物体所有顶点变量</div><div class="line">	GLuint VAO;</div><div class="line">	glGenVertexArrays(1, &amp;VAO);</div><div class="line">	//绑定VAO</div><div class="line">	glBindVertexArray(VAO);</div><div class="line">	//配置顶点属性</div><div class="line">	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);</div><div class="line">	glEnableVertexAttribArray(0);</div><div class="line">	//解绑VAO</div><div class="line">	glBindVertexArray(0);</div><div class="line">	while (!glfwWindowShouldClose(window))</div><div class="line">	&#123;</div><div class="line">		glfwPollEvents();</div><div class="line">		glClearColor(0.2f, 0.3f, 0.3f, 1);</div><div class="line">		glClear(GL_COLOR_BUFFER_BIT);</div><div class="line">		glUseProgram(shaderProgram);         //选择shader</div><div class="line">		glBindVertexArray(VAO);              //绑定VAO</div><div class="line">		glDrawArrays(GL_TRIANGLES, 0, 3);    //绘制</div><div class="line">		glBindVertexArray(0);                //解绑VAO</div><div class="line">		glfwSwapBuffers(window);</div><div class="line">	&#125;</div><div class="line">	glfwTerminate();</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码是一个简单的渲染流程，基本上分为如下几个步骤：<br>1，将顶点数据放入缓存<br>2，配置着色器<br>3，配置VAO，VAO可以看作是单个渲染物体的所有顶点属性的配置集合，所谓配置就是告诉cpu该怎样使用缓存中的数据，以把数据传递给gpu<br>4，在游戏循环中在当下环境中调用函数渲染，当下环境包括着色器,VAO.</p>
<p>由于当绘制多个图形的时候，点可能会重合，因此可以使用索引缓冲对象来解决这个问题，简称EBO，它和VBO一样，是一种缓存，同样使用glgenbuffer（）来获取ID，获取id之后，需要在VAO绑定后用glbindbuffer（）绑定EBO，然后用glbufferdata（）把索引数组复制进缓存中，特别要注意的是，在VAO绑定期间，会记录EBO的绑定，这样EBO会随着VAO的绑定而绑定，所以在解绑VAO之前不能解绑EBO，这一点与VBO不同，VAO在进行顶点属性配置的时候就相当于绑定VBO了，在配置好之后，在循环中需要调用glDrawElement（）来进行绘制。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://lefenger.com/2017/07/26/Opengl（二）——准备好窗口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lefeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AbstractSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/Opengl（二）——准备好窗口/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T17:09:54+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#define GLEW_STATIC			//静态编译必须加</div><div class="line">#include &lt;GL/glew.h&gt;</div><div class="line">#include &lt;glfw3.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)</div><div class="line">&#123;</div><div class="line">	if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)</div><div class="line">		glfwSetWindowShouldClose(window, GL_TRUE);</div><div class="line">&#125;	//按键回调函数</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	glfwInit();</div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);         //确定opengl版本</div><div class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);          </div><div class="line"> 	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</div><div class="line">	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);</div><div class="line"></div><div class="line">	GLFWwindow* window = glfwCreateWindow(800, 600, &quot;NB&quot;, nullptr, nullptr);  //获取窗口指针</div><div class="line">	if (window == nullptr)</div><div class="line">	&#123;</div><div class="line">		std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;</div><div class="line">		glfwTerminate();</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	glfwMakeContextCurrent(window);</div><div class="line">	glewExperimental = GL_TRUE;</div><div class="line">	GLenum err = glewInit();</div><div class="line"></div><div class="line">	if (GLEW_OK!=err)</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; &quot;Failed to initialize GLEW&quot; &lt;&lt; endl;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	glViewport(0, 0, 800, 600);                  //设置视口大小</div><div class="line"></div><div class="line">	glfwSetKeyCallback(window, key_callback);    //注册</div><div class="line"></div><div class="line">	while (!glfwWindowShouldClose(window))    //游戏主循环</div><div class="line">	&#123;</div><div class="line">		glfwPollEvents();                  // 检查事件</div><div class="line">		glfwSwapBuffers(window);           //切换缓冲帧</div><div class="line">		glClearColor(0.2f, 0.3f, 0.3f, 1);    </div><div class="line">		glClear(GL_COLOR_BUFFER_BIT);     //清除</div><div class="line">	&#125;</div><div class="line">	glfwTerminate();      //释放资源</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>glfw是一个工具包，用来简化一些操作，在这里可以很轻松的创建一个窗口。<br>glew， 由于opengl具有扩展特性，所以不同的显卡驱动会在实现公共opengl规范的同时，加上自己的一些拓展功能，而glew的作用是在运行之后根据当前驱动环境获取所有函数指针，原因是由于驱动版本众多，大多函数在运行之前是未确定的，所以glew会把函数指针都收集起来以便使用，当然，这就需要glew的版本足够新，从而能够囊括所有函数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://lefenger.com/2017/07/26/Opencv3.2的安装及创建一个Opencv工程的要点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lefeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AbstractSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/Opencv3.2的安装及创建一个Opencv工程的要点/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T17:09:54+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>就直接下载Opencv3.2的安装包，解压过后如下所示：<br><img src="http://img.blog.csdn.net/20170628151333955?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQWJzdHJhY3RTa3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>其中dll文件需要配置环境变量，就是把bin文件夹的路径配置到环境变量中。</p>
<h2 id="创建一个Opencv工程"><a href="#创建一个Opencv工程" class="headerlink" title="创建一个Opencv工程"></a>创建一个Opencv工程</h2><p>由于Open3.2 是64位版本的，因此也得把vs项目的目标计算机与编译平台换为64位的，方法分别如下：<img src="http://img.blog.csdn.net/20170628152257769?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQWJzdHJhY3RTa3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170628152332956?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQWJzdHJhY3RTa3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>修改完之后，还要配置头文件和lib文件。<br><img src="http://img.blog.csdn.net/20170628153027545?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQWJzdHJhY3RTa3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>包含目录与库目录分别为头文件与库文件的目录，添加进去就行。<br><img src="http://img.blog.csdn.net/20170628153203750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQWJzdHJhY3RTa3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>在附加依赖项添加库文件夹下的库文件名。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://lefenger.com/2017/07/26/Numpy中的transpose函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lefeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AbstractSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/Numpy中的transpose函数/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T17:09:54+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>transpose()的操作对象是矩阵。</p>
<p>我们用一个例子来说明这个函数：<br>[[[0 1]<br>  [2 3]]</p>
<p> [[4 5]<br>  [6 7]]]</p>
<p>这是一个shape为（2，2，2）的矩阵，现在对它进行transpose操作。<br>首先我们对矩阵的维度进行编号，上述矩阵有三个维度，则编号分别为0，1，2，而transpose函数的参数输入就是基于这个编号的，如果我们调用transpose（0，1，2），那么矩阵将不发生变化，如果我们不输入参数，直接调用transpose（），其效果就是将矩阵进行转置，起作用等价与transpose（2，1，0）。</p>
<p>在举个例子，对上面那个矩阵调用transpose（0，2，1）<br>下面为结果<br>[[[0 2]<br>  [1 3]]</p>
<p> [[4 6]<br>  [5 7]]]<br>  其实就是矩阵中每个元素按照一样的规则进行位置变换。</p>
<p>net.params[‘conv1_1’][0].data.transpose(0,2,3,1)<br>想要理解这种维数比较多的变换，得先找到变换过后的最底层，在这里就是输入维度，那么最基础的元素就是每一个过滤器在不同的输入维度上的权值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://lefenger.com/2017/07/26/MFC与stdafx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lefeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AbstractSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/MFC与stdafx/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T17:09:54+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MFC"><a href="#MFC" class="headerlink" title="MFC"></a>MFC</h2><p>   MFC即微软基础类库（英语：Microsoft Foundation Classes，简称MFC）。它以C++类的形式封装了windows api，它实际上是windows api的高层实现，各种windows句柄会被包含在MFC的相应的类中，若要进行操作只需调用相关的成员函数即可。</p>
<h2 id="stdafx"><a href="#stdafx" class="headerlink" title="stdafx"></a>stdafx</h2><p>  stdafx.h中包含了所有需要预编译的头文件，用户可以自行添加，预编译是只部分高频使用的头文件预先编译以避免重复编译，因此大大减少了编译时间。需要注意的是，stdafx.h应第一个被包含，因为stdafx.h之前的头文件都会被忽略掉。<br>  至于stdafx.cpp,直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// stdafx.cpp : 只包括标准包含文件的源文件</div><div class="line">// Opencvtest.pch 将作为预编译头</div><div class="line">// stdafx.obj 将包含预编译类型信息</div><div class="line"> #include &quot;stdafx.h&quot;</div><div class="line">// TODO: 在 STDAFX.H 中引用任何所需的附加头文件，</div><div class="line">//而不是在此文件中引用</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://lefenger.com/2017/07/26/CS231n 学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lefeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AbstractSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/CS231n 学习笔记/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T17:09:54+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、人大脑处理图像的第一步是对边界和形状的识别，图像分类到图像识别。</p>
<p>二、K-近邻算法：</p>
<p>1 .监督学习，是一种即时分类非参数算法，对测试集中的每一张图片，遍历训练集，计算两张图片的相似度，相似度的计算方法为计算每个对应像素之间的距离（所谓的距离可能使用欧氏距离或曼哈顿距离），然后相加，最终得到相似度最小的K张图片，从而根据标签占比得到最终标签（即分类）。</p>
<p>2.该算法同样可用于回归，例如根据k个近似数据对相应特征进行加权从而得到预测值，再与实际值比较，然后对参数进行调整。</p>
<p>3.该算法缺点在于计算量随着训练样本数目的增加而增加。同时相似度的计算（只计算对应像素的距离）使其泛化程度较低（图片的transform等等），优点是不需要训练。</p>
<p>三、线性分类器：</p>
<p>1.有参数学习算法，假设训练样本规格为512×512，要分类的标签为5个，那么要训练的模型就有（512×512）×5个权值w（分别对应图片的每一个像素）以及5个偏置值b。</p>
<p>2.训练过程为：图片所有像素值的加权和与b相比较，从而得到各个标签的分类概率。</p>
<p>3.如果将每种标签的所有权值还原成一张权值图片（这里有5张512×512的图片），假设图片为单通道，那么权值图片中某一处像素值的高低就代表对输入图片在此位置的激活程度。</p>
<p>4.这种线性分类器，对于每一种分类标签来说，只是单模型分类，举个识别马的例子，马头向左与向右都应该被识别出来，但是这需要体现在一张权值图片中，因此识别马的权值图片中可能出现一只拥有两个头的马。而神经网络则不存在这种问题。</p>
<p>五、线性分类器的损失函数（Multiclass SVM Loss）</p>
<p>1.输入一张训练样本，当计算出每个分类的score后(由我们所要训练的函数得到)，使用损失函数计算损失，计算公式为：令scores中正确分类的score为rs，分别用其余非正确score减去rs得到s，再max（0，s+1），最终相加，在除以标签的个数，最终就得到了loss值。这里的max（0，s）表示如果非正确score小于rs，则置为0，表示不对loss结果产生影响，这里1是一个安全参数，若非正确score虽然比rc小，但十分接近，仍然会对loss结果产生影响，这里的1只是随便设的，需要根据score来设定。</p>
<p>2.在这里是直接计算非正确score与rs的差值，也可以使用差值的平方。</p>
<p>3.还有一个知识点就是损失函数的正则化，就是在损失函数末加上l*R（w），R（w）有多种形式，一般使用所有W平方的和，正则化的作用是将W值的分布的影响加入到loss函数中，换句话说，加入正则项的话，即使score一样，但R（w）却不一定一样，那么loss结果也就不一样。我觉得有一个描述特别形象，正则化就相当于和损失函数进行对抗，它努力使权值关注图像中的大多数像素，在视频中有人说也许只关注部分效果会更好，的确训练样本的效果也许会更好，但是关注更多点可以增强泛化能力，可以使模型适用于更多种类的测试样本。</p>
<p>六、线性分类器的损失函数（Softmax Classifier，即一般性的逻辑斯特回归） 1、得到各个标签的score之后，使scores分别作为e的指数，得到scoresN，再分别计算scoresN中各自的占比得到scoresNN，最后再对scoresNN中的数进行log运算（10为底）最终得到scoresNNN，取出其中的正确分类的数值就是SoftmaxClassifier的loss值。</p>
<p>2.进行log操作是因为scoresNN中的正确分类的比例如果很小的话，那么log的结果就会很大，即loss值很大。</p>
<p>七、Softmax与SVM的区别： 1.SVM具有附加的稳定性，因为当错误score减去正确score的值小于安全系数的话，就会置为0，从而忽略错误概率，而Softmax中，即使错误score的评分远小于正确score，它也会将错误概率计算到loss中，因此SVM对于接近分类边界的样本更加敏感。</p>
<p>八、优化方法（SGD，即随机梯度下降） 1.所谓优化就是通过改变W来降低Loss的过程。 2.SGD过程就是选择一个batch-size（一般为32,64,256等等），不能太大，这样是为了gpu内存着想，然后计算梯度值，再使每个w减去（-步长*梯度值），直到收敛。 3.步长就是下降速率，是一个超参数，一般随着训练过程不断减小，如果一直很小的话，迭代次数会增加，耗时长，并且会误入局部最小值的坑中无法自拔。</p>
<p>九、线性分类器总结 1.无法直接对像素进行操作，因此需要对输入数据进行特征提取和预处理。（Weka中可以自己试试，只需要特征提取就行了） 2.神经网络不需要特征提取了，能直接输入像素。</p>
<p>十、正向传播与反向传播算法 1.正向传播就是根据输入经过一系列运算门得出结果。</p>
<p>2.整个神经网络可以看成由许多有序的数据层组成，层与层之前是各种门运算，反向传播就是为了计算每一个数据层的梯度，所谓的梯度就是当前数据层对最终结果产生影响的速率大小，如果梯度为3，那么表明如果当前数据层数值加一，最终结果就会加3.</p>
<p>3.计算梯度的方法：从网络末端往前计算梯度，假设表达式为f=（x+y）<em>z，输入x=1，y=2，z=3，那么末层就是计算（x+y）z的梯度，就是f的梯度，就是对f求导，梯度肯定就是1了，假设前面一层是x+y与z，正传播时x+y=3，z=3，那么对x+y求导等于3，在此特别要注意的是，根据链式法则，每一层的梯度等于当前局部梯度乘以后一层的梯度，那么x+y的梯度就是3</em>1=3，同理z的梯度也是3.</p>
<p>4.层与层之间的运算可能不是单一的，可以把多种运算放到一起，然后输出一个层。</p>
<p>5.输入层的局部梯度恒为1，输出层的梯度恒为1，如果每一层是由前面若干个层相加得来的，那么前面的层的梯度都等于当前层并且加法运算前面的层的局部梯度也是恒等于1的，如此看来，加法运算具有梯度共享的功能，换句话说，加法运算使得前面两个层可以拥有相同的梯度，即对最终结果产生相同的影响。无独有偶，不同的运算拥有不同的功能，如max运算只会输出最大数值的那个层，意思就是把数值小的那个层的梯度设为0，那么这就实现了路由的效果。</p>
<p>6.通过第5条所说的概念，可以想到，神经网络不仅仅再局限为描述一个表达式了，它可以看做是对输入数据的一系列运算。如果一个数据层将被同时用作于两个运算，那么它将拥有两条分支，每条分支都会产生相应的梯度，那么当前梯度的梯度就是两条分支梯度之和。</p>
<p>7.Sigmoid激活函数的缺点是速度较慢，且当输入数据处于函数两头时，它的局部梯度将接近于0，且输出不是0就是1，这会出现所谓的梯度消失现象，因为根据链式法则，一个接近于0的局部梯度乘以前面的梯度会使结果十分小，那么修正参数的速度就会非常慢。</p>
<p>8.根据经验，预处理数据时，应该使数据关于原点对称，如在f=wx+b中，如果输入的x全为正或负，那么w的梯度就全为正或负，因为wx中对w求偏导的结果为x。</p>
<p>9.ReLu激活函数：速度十分快，约为sigmoid的6倍。&gt;0时不会饱和，如果输入大于0，则会直接传播梯度（梯度为1），输入小于0时，正向传播输出为0，梯度也为0，相当于被屏蔽了。</p>
<p>10.数据预处理：在图像中，一般只需中心化，就是求出图像每个通道的均值，会得到一张纯色的均值图像，然后让原图减去均值图像。机器学习中会用到归一化，而图像像素（rgb）总是在0-255中，所以不需要。</p>
<p>11.权值的初始化：不能全为0，否则所有的神经元都在做同样的事情，传播的梯度也是一样的，因为w=0，wx=0，输出只为b。 当使用tanh作为激活函数时，tanh是中心对称函数，我们使用均值为0，方差为0.01来初始化权值，由于权值很小，所以每个神经元的输出都很小，那么在反向传播中，w的梯度就等于x的值，然而每个x的输入都十分小，那么w的梯度也就十分小，当求x的梯度时（将乘以前面的局部梯度），由于初始化时w的值很小，那么x的梯度也很小，这直接导致前面层的局部梯度将乘以一个很小的值，最终导致所有w的梯度都很小，这就是梯度弥散。当我们使用均值为0，方差为1来初始化权值时，由于权值过大，在tanh激活函数中将会饱和，因此每个神经元的输出不是1就是-1，并且此时梯度为0，所以也会导致梯度弥散。</p>
<p>12.BN（Batch Normalization）层，一般放在非线性层前面，用于将输入gaussian unit(方差为1，均值为0) ，并且还可以加权和偏移，可以先设置成1和0，然后再改变。通过BN来避免出现梯度弥散和爆炸，它减少了算法对合理的初始化的依赖性。并且产生了正则化的效果。根据我的初步理解，BN就是为了让人们不再为了这样初始化而苦恼,BN配合Sigmoid激活函数效果更好。</p>
<p>13.超参数的取样要在对数空间中进行，当神经网络不是很小时，局部最优解不再是一个问题。</p>
<p>14.Momentum Update，与SGD相比，这种方式更加快。 SGD中权值的更新方式为x+=-learning_ratedx， Momentum Update中更新方式为x+=mu *v-learning_ratedx 在这里，mu是一个超参数，其功能类似于阻尼系数，-learning_ratedx就相当于加速度，v一般会初始化为0，实际上，我觉得它与SGD最大的不同就是它是于迭代次数息息相关的，迭代次数多了，速度必然会大幅度减小，最终会变得极为缓慢（指数级衰减），而SGD由于只会朝着最优解前进，不仅在前期可能会发生震荡，而且接近谷底时也不会缓慢下来。</p>
<p>15.NAG(Nesterov Accelerated Gradient) 与Momentum不同的是，它不计算当前位置的梯度，而是计算预测位置的梯度，然后在计算Momentum梯度与预测梯度的矢量和来作为最终的梯度。它的收敛速度要比Momentum更快。</p>
<p>16 . AdaGrad update 这里写图片描述 如图所示，这种更新方式最大的特点是每个参数都拥有自己的自适应学习速率，cache的值是每次迭代的梯度的平方和，所以当累积的梯度较少时，分母就会比较小，那么学习速度就很快，反之同理。这里的1e-7是平滑因子，为了防止分母为0。 RMSProp update 这里写图片描述 由于AdaGrad update随着迭代次数变多，梯度的不断累积会让分母变得很大，最终参数的更新将会停止，为了防止这种情况的发生，RMSProp update增加了衰减参数decay_rate,使得参数的更新一直进行。</p>
<p>17.AdamUpdate 就是将RMSProp和Momentum结合起来，这部分我完全没听懂，不过这是最常使用的方法。</p>
<p>18.除了一阶优化（只使用梯度），还有二阶优化（梯度和损失函数曲面弯曲度），这部分没详细讲，我也没听懂。</p>
<p>19.Dropout（随机失活） 通过随机数使某一个隐含层随机失活，前向和反向传播均需要随机失活。随机失活使用的原因，防止过拟合，由于神经元的失活是随机的，所以这可以使特征的识别更加多样，避免依赖于某一个或几个神经元。另一个解释是，每一次随机失活，就会产生一个网络子集，每一次训练，都是一个网络子集使用一个数据进行训练，这些子集是交叉（局部数据共享）的，因此整个神经网络就可以看作是许多个子集的结合。 在训练阶段我们使用随机失活，可是在测试阶段中我们不使用，这就导致了测试阶段中的数据整体要比训练阶段大一倍（这里的dropout是使一半的神经元失活），因为测试阶段用到了所有的神经元，解决方法有两种：1.测试阶段的每个神经元的激活函数除以相应的倍数，这里是2。2.训练阶段每个神经元的激活函数乘以相应倍数。</p>
<p>十一、卷积神经网络 过滤器的规格应与上一层的数据规格相同，点积运算时要把所有的通道的点乘过后的数据加起来作为结果，这一点很关键，意思是每一个过滤器都把前一层的所有的通道结合乘一张图，如32×32×3通过5×5×3得到28×28，三个通道合并成了一个通道。当使用1×1作为过滤器时，相当于对纵深进行点积。池化层只会减小长宽，不会减小维度。网络的最后是全连接层，把所有维度的图像展开成列向量，然后分别计算每个分类的评分。 在全连接层中，有几个分类，就用几个神经元，且随机失活只在全连接层中使用。</p>
<p>十二、迁移学习之物体定位与检测 1.通过滑动窗的方法来强化效果（就是通过计算在原图上不同位置的输入来得到多个类分数和定位，在结合起来得到更精确的输出），例如神经网络的输入规格为100<em>100，而原图片为400 </em> 400，那么不断滑动输入图像，从而得到不同的类分数和定位（方框），最终通过一些方法合并，从而得到最终的类分数和定位。 通过将全连接层看成卷积层，这样我们可以在不同大小的图片上使用相同的计算过程，大大提高了效率，因为如果是全连接层的话，前一层的只能是一组输入，而由于卷积层有滑动的功能，因此可以对多组输入进行相同的计算。 第一段中所说的通过计算在原图的不同位置的输入来得到更精确的结果的方法，如果原图为400<em>400，而输入规格为300</em>300，那么将会有4组输出，但是由于4组输入的图片有大量重叠的部分，那么一个个算的话肯定也有大量重复的计算，为了避免这种情况，我们将用到第二段所说的思想。举一个例子，原图为16<em>16，输入规格为14</em>14,当我们输入左上角的14<em>14，假设全连接层前一层的输入为5</em>5,经过5<em>5的卷积层后输出为1</em>1（事实上神经网络全连接层的前一层的输出为特征向量），那么现在我们把全连接层看成卷积层，我们就可以处理多组输入了，我们现在可以直接向网络中输入16<em>16的原图，那么全连接层的前一层输入可能为6</em>6，经过5<em>5的卷积层后输出为2</em>2，这里的输出为之前的4倍，那么经过全连接层后的输出也就会有4组，而这4组输出就是在16*16的原图的不同位置网络所得到的输出，这种方法比之前一个个算节省了大量的时间。 2.具体训练分类及定位网络的方法，获取分类网络（就是一些nb的分类网络去掉尾部），获取训练集，对训练集使用选择性搜索算法（就是事先筛选出原图可能为所要分类的实例的区域，这样神经网络就不用在原图上一个个试了），然后用回归的方法不断调整实例框（事实上前面使用的选择性搜索算法（除了这个，还有很多种）已经为我们确定了实例框的大概的位置和大小），用分类来识别分类种类。我们要训练二分类svm来确定图像区域中是否包含对象。</p>
<p>十三、可视化<br>    可视化工具： t-SNE<br>    DeCov方法，如果想要知道某一个神经元对图片的梯度，可以将网络中所有梯度设为0，然后将指定的那个神经元的梯度设为1，这样反向传播就会从这里开始。但这样得出的梯度图难以理解，因为梯度的正影响和负影响相互干扰，因此若要使梯度图十分清晰，就要使relu层也对反向传播有效，即拦截负向传播。<br>    可视化有个很重要的应用是：通过对输入的图片（为空白图）进行优化，所谓优化就正向-反向-优化，然后就可以得到使某个分类的分数最大化的图片，这里要注意的是，在这里的网络是有损失函数的，即是有目标的，而且这个网络的所有权值都是经过大量训练且稳定可靠的。通过这样的操作，就可以看出怎样的图片输入可以最大化激活网络中某一个分类。不仅仅针对于某个分类，也可以针对网络中的任意一个神经元，不需要损失函数也可以。<br>    把一个图片进行正向传递，便能得到分类前的特征图，那我们可以尝试着只依据特征图还原出原图，具体方法也是保持网络不变，只对图片进行优化，只不过要设损失函数，损失函数为当前特征图减去原图的特征图。从实验结果来看，如果直接对分类前的特征图进行还原，只能看见一些基本的信息，而越向前取特征图，则还原度越高，由此可见，随着网络的深入，图像的解析越来越抽象。<br>    Deep dream：在原始图片中放大网络中的某一个神经元（或某一层）的激活信息。举个例子，我们想在神经元x上“做梦”，即我们想在图像中放大神经元x的激活信息，假设”狗头“能够最大化激活神经元x，那么通过对输入图片进行优化，网络就得努力使图片上充满”狗头“，那么怎么才能做到呢？具体做法为：当正向传播到我们选择的神经元时，我们直接将这个神经元的梯度置为这个神经元的激活图，注意在此网络中需要使relu对正反向传播都进行拦截，以免正负相互干扰，这样一来激活程度大的地方梯度越高，当这些梯度反向传播时会达到怎样的效果呢？网络会对这些梯度一步步进行解析，最终作用在图像上，换句话说，反向传播的过程中网络在思考图像该怎样变化才能符合那个神经元的梯度。<br>    在图像风格转换中，之所以要将内容的loss加上是为了保证图像像素的位置对应，若没有内容图的内容表达，得出的结果会是乱序的。<br>    在课程的最后，讲师说了一个尚未解决的问题，就是对抗样本的问题，这个问题出现的原因是（我的理解）：图像的维度太高，有太多的空间没有被训练过，因此神经网络不知道该如何正确的训练，举个例子：用鸵鸟的梯度来优化狗的照片，按理说狗应该越来越像鸵鸟，但实际上狗的照片只是产生了细微的变化却达到了很低的loss，那么这张图就称为对抗样本，因为神经网络在优化的过程中对图片的每个维度都向最优解前进一小步，导致loss发生了很大的变化。对抗样本会有很多不好的影响，例如在得到某张图的对抗样本之后，就可以用对抗样本骗过神经网络。</p>
<p>重点：1用于分类的网络，最终得出的结果必然是通过损失函数计算出的误差值。 2.像VGG，GoogleNet这样的网络，我们可以去掉最后的全连接层来为己所用，像这种分类网络，最后的全连接层基本都是损失函数。而我们可以利用的是网络提取图片特征的能力，它既然能够分类出1000种事物，那么它肯定能很好的提取图片中的特征并抽象复杂化。 3、每个神经元都有自己的一组权值和一个偏移值，还有相应的激活函数。 4、大致上卷积神经网络可看成是由卷积层和全连接层组成的，而全连接层也可以看做一种特殊的卷积层，即每个神经元都可以看做是长宽步长均为1的过滤器。5、神经网络的特征提取能力取决于当初训练时所提供的样本，比如训练样本全部为各种各样的狗时，这个网络就特别擅长于提取狗的特征。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://lefenger.com/2017/07/26/Caffe中的Net/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lefeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AbstractSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/Caffe中的Net/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T17:09:54+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Net这个类代表着一个神经网络。</p>
<h2 id="一个Net的创建"><a href="#一个Net的创建" class="headerlink" title="一个Net的创建"></a>一个Net的创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cafferoot=&apos;/home/abstractsky/caffe&apos;   </div><div class="line">caffe.set_mode_gpu                 #在GPU上运行</div><div class="line">deployfile=&apos;/home/abstractsky/公共的/style-transfer-master/models/vgg16/VGG_ILSVRC_16_layers_deploy.prototxt&apos;  #deploy文件</div><div class="line">modelfile=&apos;/home/abstractsky/公共的/style-transfer-master/models/vgg16/VGG_ILSVRC_16_layers.caffemodel&apos;   #caffemodel文件</div><div class="line">net=caffe.Net(deployfile,modelfile,caffe.TEST)</div></pre></td></tr></table></figure>
<h2 id="Net中的数据"><a href="#Net中的数据" class="headerlink" title="Net中的数据"></a>Net中的数据</h2><p>网络中的数据都是通过Blob这个类进行传输的，这个类可看作是四维数据的集合.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print type(net.blobs)</div><div class="line">print &apos;\n&apos;</div><div class="line">for layer_name, blob in net.blobs.iteritems():</div><div class="line">    print layer_name + &apos;\t&apos; + str(blob.data.shape)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">输出：</div><div class="line">&lt;class &apos;collections.OrderedDict&apos;&gt;</div><div class="line">  #这个类型可看作是有序的字典集合</div><div class="line"></div><div class="line">data	(1, 3, 224, 224)</div><div class="line">conv1_1	(1, 64, 224, 224)</div><div class="line">conv1_2	(1, 64, 224, 224)</div><div class="line">pool1	(1, 64, 112, 112)</div><div class="line">conv2_1	(1, 128, 112, 112)</div><div class="line">conv2_2	(1, 128, 112, 112)</div><div class="line">pool2	(1, 128, 56, 56)</div><div class="line">conv3_1	(1, 256, 56, 56)</div><div class="line">conv3_2	(1, 256, 56, 56)</div><div class="line">conv3_3	(1, 256, 56, 56)</div><div class="line">pool3	(1, 256, 28, 28)</div><div class="line">conv4_1	(1, 512, 28, 28)</div><div class="line">conv4_2	(1, 512, 28, 28)</div><div class="line">conv4_3	(1, 512, 28, 28)</div><div class="line">pool4	(1, 512, 14, 14)</div><div class="line">conv5_1	(1, 512, 14, 14)</div><div class="line">conv5_2	(1, 512, 14, 14)</div><div class="line">conv5_3	(1, 512, 14, 14)</div><div class="line">pool5	(1, 512, 7, 7)      #这些都是网络中各个层的输入规格</div></pre></td></tr></table></figure>
<h2 id="Net中的参数"><a href="#Net中的参数" class="headerlink" title="Net中的参数"></a>Net中的参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">for layer_name, param in net.params.iteritems():</div><div class="line">    print layer_name + &apos;\t&apos; + str(param[0].data.shape), str(param[1].data.shape)</div><div class="line"></div><div class="line">输出：</div><div class="line">conv1_1	(64, 3, 3, 3) (64,)</div><div class="line">conv1_2	(64, 64, 3, 3) (64,)</div><div class="line">conv2_1	(128, 64, 3, 3) (128,)</div><div class="line">conv2_2	(128, 128, 3, 3) (128,)</div><div class="line">conv3_1	(256, 128, 3, 3) (256,)</div><div class="line">conv3_2	(256, 256, 3, 3) (256,)</div><div class="line">conv3_3	(256, 256, 3, 3) (256,)</div><div class="line">conv4_1	(512, 256, 3, 3) (512,)</div><div class="line">conv4_2	(512, 512, 3, 3) (512,)</div><div class="line">conv4_3	(512, 512, 3, 3) (512,)</div><div class="line">conv5_1	(512, 512, 3, 3) (512,)</div><div class="line">conv5_2	(512, 512, 3, 3) (512,)</div><div class="line">conv5_3	(512, 512, 3, 3) (512,)</div></pre></td></tr></table></figure>
<p>net.params同net.blobs一样，都是collections.OrderedDict类型。而net.params中的元素是Blob的容器（C++中的vector），在这里包含两个blob，分别表示Conv层中的weight和bias.weight中的四个参数分别表示输出的维数、输入的维数、过滤器的高、过滤滤的宽，事实上这也就是这个conv层中的所有参数个数。</p>
<p>初学不久，相互交流。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://lefenger.com/2017/07/26/Caffe  问题记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lefeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AbstractSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/Caffe  问题记录/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T17:09:54+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1,当    caffe为训练模式时，dropout不执行。</p>
<p>2,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">layer</div><div class="line">&#123;    </div><div class="line">    bottom: &quot;a&quot;</div><div class="line">    bottom: &quot;b&quot;</div><div class="line">    name: &quot;conv1_1&quot;</div><div class="line">    param</div><div class="line">    &#123;</div><div class="line">	 propagate_down : 0  //a不会得到梯度传播</div><div class="line">	 propagate_down : 0  //b不会得到梯度传播</div><div class="line">	 lr_mult: 0 # 学习率为0   //此层参数不会改变，可用于finetune</div><div class="line">    &#125;</div><div class="line">    # set loss weight so Caffe knows this is a loss layer  </div><div class="line">    loss_weight: 1  //告诉caffe这是一个loss层</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://lefenger.com/2017/07/26/《线性代数》学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lefeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AbstractSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/《线性代数》学习笔记/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T17:09:54+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、消元法<br>第一步先找到三个主元（povit），主元不能为零。主元在矩阵的对角线上，如果对角线上的值为0的话，就交换行，但如果消元到最后一行时主元为零，则这次消元失败，这个矩阵称为不可逆矩阵。而行列式（determinant）的值就是对角线上主元的乘积。</p>
<p>矩阵乘向量与向量乘矩阵的含义与区别：矩阵乘向量是对矩阵中列的线性组合，而向量乘矩阵是对矩阵中行的线性组合。<br><img src="http://img.blog.csdn.net/20170709185123746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQWJzdHJhY3RTa3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20170709191539826?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQWJzdHJhY3RTa3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>由以上两条可得出一个结论：当两个矩阵相乘时，左边矩阵中的每一行都可看作是对右边矩阵行的线性组合，右边矩阵中的每一列都可看作是对左侧矩阵列的线性组合。<br>那么消元的过程自然也就可以用矩阵的乘积代替。并且交换行与交换列也可以用上面的理论。</p>
<p>矩阵的逆实际上就是找出一个矩阵能够消除对原矩阵的变换，即逆矩阵E^-1*E=单位矩阵。其中E为转换矩阵。</p>
<p>矩阵乘法具有结合律，E1(E2A)=(E1E2)A  ，其中E表示消元矩阵和初等矩阵，听说结合律的证明挺复杂。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://lefenger.com/2017/07/26/《编程范式》学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lefeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AbstractSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/《编程范式》学习笔记/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T17:09:54+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>(一)编程范式<br>（1）八位能表示最大的数是多少？<br>为255，最多能表示256个数（包括0），2^x=2^0+2^1+2^2+2^3+…………+2^(x-1)+1</p>
<p>（2）二进制计算：负整数与正整数相加的结果0时，是如何进行二进制运算的？<br>以short类型（2字节）为例，00000000 00001111 与10000000 00001111相加，对后者取反加1得到11111111 11110001，相加便得到00000000 00000000。-1的二进制表示是个例外，以short为例，为11111111 11111111，因为1的表示为0000 0001，相加正好为0。</p>
<p>（3）不同数据类型之间的赋值<br>字节数小的赋值给字节数大的，例char赋值给short，00001111转化为short类型，结果为00000000 00001111。字节数大的赋值给字节数小的，例01010000 00001111转化为char类型，则舍弃多余的字节得到00001111，在这里有个误区，例A类型最大能表示的值为100，现在想要将值为123的B类型转化为A类型，不能想当然的认为转换后为100。另外由于-1的char表示为1111 1111，若要将其转化为short类型，需要进行符号扩展，从而变成11111111 11111111。</p>
<p>（4）浮点数的二进制是如何表示的，以float为例？<br>数学公式为 （符号位）1.xxxx*2^(exp-127)         exp为八位无符号整型，范围为-255~255<br>[符号位][八位无符号整型，即exp][23位表示小数（2^-x），即.xxxx]</p>
<p>（5）强制类型转换（简单讲讲）<br>float j=4.0；<br>int i=<em>（int </em>）&amp;j；<br>此时j的各位值都不会变，而i会照搬其各位的值，当然，获得的值不是4。<br>float j=4.0；<br>short i=<em>（short </em>）&amp;j；<br>此时short类型只有2个字节，因此只将float的前两个字节的数照搬过来。<br>（二）C语言<br>（1）struct</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct exm</div><div class="line">&#123;</div><div class="line">	int a;</div><div class="line">	int b;</div><div class="line">&#125;</div><div class="line">exm sa;</div><div class="line">sa.a=1;</div><div class="line">sa.b=2;</div><div class="line">print (exm *)&amp;（sa.b）-&gt;a</div></pre></td></tr></table></figure>
<p>得出的结果为2，其中原理如图：<br><img src="http://img.blog.csdn.net/20170618103257690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQWJzdHJhY3RTa3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(exm *)&amp;（sa.b）-&gt;b=3;<br><img src="http://img.blog.csdn.net/20170618105724729?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQWJzdHJhY3RTa3k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>print((&amp;sa)[1].a)     输出为3，其中原因为把&amp;sa当成了数组首地址，基础单位为exm。</p>
<p>(2)无论是string、int、float、short，他们都是线性寻址，举个Int的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int x=1；</div><div class="line">int y=2;</div><div class="line">swap(&amp;x,&amp;y)；</div><div class="line">int swap(int *xp,int *yp)           //xp，yp为x、y的地址</div><div class="line">&#123;</div><div class="line">	int temp=*xp;</div><div class="line">	*xp=*yp;</div><div class="line">	*yp=temp;                           //这里的*x就相当于int类型的x</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于其他类型来说，所做的操作也是一样的，就是根据一个地址逐单位寻址。</p>
<p>(3)我们可以编写一个具有泛化能力的swap函数，它将是一个可以输入任何类型的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void swap(void *vp1,void *vp2,int size)</div><div class="line">&#123;</div><div class="line">	char buffer[size];</div><div class="line">	memcpy(buffer, vp1,size);</div><div class="line">	memcpy(vp1, vp2,size);</div><div class="line">	memcpy(vp2, buffer,size);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中memcpy函数前两个参数为指针，第三个参数为复制字节数，它会根据字节数按顺序对指针进行解引用并复制内容。<br>这个函数可以接受任何类型的输入，它不关心输入的为什么类型，只关心首地址与复制长度。s事实上任何类型的输入都不会引发编译器的报错。一下为几个特例：<br>(a)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">short a=2;</div><div class="line">int b=3;</div><div class="line">swap(&amp;a,&amp;b,sizeof(short)) //只会复制前两个字节</div></pre></td></tr></table></figure>
<p>(b)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">char *a=strdup（&quot;1234&quot;）;     //strdup() 可在堆中为一个char数组分配内存，并返回首地址。</div><div class="line">char *b=strdup(&quot;4567&quot;);</div><div class="line">swap（&amp;a,&amp;b,sizeof(char *));       //char *为指针类型，为四个字节.</div><div class="line">cout&lt;&lt; a&lt;&lt;endl;                //输出为4567</div><div class="line">cout&lt;&lt; b&lt;&lt;endl;	            //输出为1234</div></pre></td></tr></table></figure>
<p>在这段程序中，swap的输入实际上为char**类型，以a举例，1234四个字符的值在堆中，他们相应的指针在栈中保存，而输入为&amp;a，这意味着输入为指针的地址，所以swap所交换的实际上是指针的值，由于size为4，所以只交换数组首地址的值，首地址交换，输出的值自然也就交换了。</p>
<p>(c)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">char *a=strdup（&quot;1234&quot;）;     //strdup() 可在堆中为一个char数组分配内存，并返回首地址。</div><div class="line">char *b=strdup(&quot;4567&quot;);</div><div class="line">swap（a,b,sizeof(char);       //char *为指针类型，为四个字节.</div><div class="line">cout&lt;&lt; a&lt;&lt;endl;                //输出为4234</div><div class="line">cout&lt;&lt; b&lt;&lt;endl;	            //输出为1567</div></pre></td></tr></table></figure>
<p>在这段程序中，swap的输入为char*类型，即将数组首地址传入，size为1，因此所改变的实际上为堆中数组的值。</p>
<p>(4)    我们将再写一个具有泛化能力的搜索函数，就是在一个数组中搜索指定的值。<br>void <em> lsearch（void </em>key,void *base,int n,int elemSize）     //key为想要搜索的值，base为数组首地址，n为数组元素个数，elemSize为数组中元素大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	for（int i=0;i&lt;n;i++）</div><div class="line">	&#123;</div><div class="line">		void *  elemAddr=(char *)base+i*elemSize*i;        //在这里是数组首地址的平移</div><div class="line">		if（memcmp（key，elemAddr，elemSize）==0）//memcmp是一个比较函数，他会根据size依次对字节的值进行比较。</div><div class="line">		&#123;</div><div class="line">			return elemAddr；    //返回结果指针</div><div class="line">			</div><div class="line">	&#125;</div><div class="line">     &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/tx.jpg"
               alt="Lefeng" />
          <p class="site-author-name" itemprop="name">Lefeng</p>
           
              <p class="site-description motion-element" itemprop="description">Today is my whole life.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lefeng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
